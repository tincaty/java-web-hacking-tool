package com.web.webservices;


import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import com.web.webDTO.ScanRequestDTO;
import com.web.webDTO.ScanResponseDTO;

import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;
import java.lang.management.MemoryUsage;
import java.util.*;
import java.util.concurrent.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@Service
public class VulnerabilityScannerService {

    private static final int CONCURRENCY_LEVEL = 5;
    private static final int MAX_MUTATION_ATTEMPTS = 3;
    private static final long MEMORY_THRESHOLD_BYTES = 1024 * 1024; // 1MB
    private static final double MEMORY_THRESHOLD_PERCENT = 5.0;

    private final RestTemplate restTemplate;
    private final ExecutorService executorService;
    private final MemoryMXBean memoryMXBean;
    private final List<Pattern> memoryErrorPatterns;
    private final Map<String, String> bypassHeaders;
    private final Map<String, String> bypassPayloads;
    private final Random random = new Random();

    public VulnerabilityScannerService() {
        this.restTemplate = new RestTemplate();
        this.executorService = Executors.newCachedThreadPool();
        this.memoryMXBean = ManagementFactory.getMemoryMXBean();

        // Initialize memory error detection patterns
        this.memoryErrorPatterns = compileMemoryErrorPatterns();

        // Initialize bypass techniques
        this.bypassHeaders = initializeBypassHeaders();
        this.bypassPayloads = initializeBypassPayloads();
    }

    public ScanResponseDTO scanEndpoint(ScanRequestDTO request) {
        ScanResponseDTO response = new ScanResponseDTO();
        List<String> bypassTechniques = new ArrayList<>();
        List<String> analysisNotes = new ArrayList<>();

        try {
            // Record initial memory state
            MemoryUsage heapBefore = captureMemoryUsage("Initial memory state", analysisNotes);

            // Special handling for concurrent testing
            if (request.getAttackType().equals("TOCTOU via Memory Race")) {
                return performConcurrentTesting(request, analysisNotes);
            }

            // Prepare request components
            HttpHeaders headers = prepareHeaders(request, bypassTechniques);
            String finalPayload = preparePayload(request, bypassTechniques, analysisNotes);

            // Execute the request
            ResponseEntity<String> apiResponse = executeRequest(request, headers, finalPayload);

            // Analyze memory changes
            MemoryUsage heapAfter = captureMemoryUsage("Post-request memory state", analysisNotes);
            analyzeMemoryChanges(heapBefore, heapAfter, analysisNotes);

            // Analyze response for vulnerabilities
            boolean isVulnerable = analyzeResponse(
                request.getAttackType(), 
                apiResponse.getBody(), 
                analysisNotes
            );

            // Build comprehensive response
            buildResponse(
                response, 
                request, 
                isVulnerable, 
                bypassTechniques, 
                apiResponse.getBody(), 
                finalPayload, 
                analysisNotes
            );

        } catch (Exception e) {
            handleError(response, e);
        }

        return response;
    }

    // ========== Memory Analysis Features ==========

    private MemoryUsage captureMemoryUsage(String context, List<String> notes) {
        MemoryUsage usage = memoryMXBean.getHeapMemoryUsage();
        notes.add(String.format("%s - Used: %d MB, Max: %d MB", 
            context,
            usage.getUsed() / (1024 * 1024),
            usage.getMax() / (1024 * 1024)));
        return usage;
    }

    private void analyzeMemoryChanges(MemoryUsage before, MemoryUsage after, List<String> notes) {
        long usedDiff = after.getUsed() - before.getUsed();
        double diffPercentage = (double) usedDiff / before.getMax() * 100;

        notes.add(String.format("Memory change: %+d bytes (%.2f%% of max)", 
            usedDiff, diffPercentage));

        if (usedDiff > MEMORY_THRESHOLD_BYTES) {
            notes.add("WARNING: Significant memory increase (>1MB) - possible memory leak");
        }

        if (diffPercentage > MEMORY_THRESHOLD_PERCENT) {
            notes.add(String.format(
                "WARNING: Large relative memory increase (>%.1f%%) - possible inefficient memory handling", 
                MEMORY_THRESHOLD_PERCENT));
        }
    }

    // ========== Concurrent Testing Features ==========

    private ScanResponseDTO performConcurrentTesting(ScanRequestDTO request, List<String> notes) {
        notes.add("Initiating concurrent race condition test with " + CONCURRENCY_LEVEL + " threads");
        MemoryUsage heapBefore = captureMemoryUsage("Pre-concurrent test memory", notes);

        try {
            HttpHeaders headers = prepareHeaders(request, new ArrayList<>());
            String finalPayload = preparePayload(request, new ArrayList<>(), notes);

            List<CompletableFuture<ResponseEntity<String>>> futures = IntStream.range(0, CONCURRENCY_LEVEL)
                .mapToObj(i -> CompletableFuture.supplyAsync(
                    () -> executeRequest(request, headers, finalPayload), 
                    executorService))
                .collect(Collectors.toList());

            List<ResponseEntity<String>> responses = futures.stream()
                .map(f -> {
                    try {
                        return f.get(10, TimeUnit.SECONDS);
                    } catch (Exception e) {
                        notes.add("Concurrent request failed: " + e.getMessage());
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

            MemoryUsage heapAfter = captureMemoryUsage("Post-concurrent test memory", notes);
            analyzeMemoryChanges(heapBefore, heapAfter, notes);

            boolean isVulnerable = detectRaceConditions(responses, notes);
            String responseSummary = buildConcurrentResponseSummary(responses);

            ScanResponseDTO concurrentResponse = new ScanResponseDTO();
            buildResponse(
                concurrentResponse,
                request,
                isVulnerable,
                new ArrayList<>(),
                responseSummary,
                request.getJsonPayload(),
                notes
            );
            return concurrentResponse;

        } catch (Exception e) {
            ScanResponseDTO errorResponse = new ScanResponseDTO();
            handleError(errorResponse, e);
            return errorResponse;
        }
    }

    private boolean detectRaceConditions(List<ResponseEntity<String>> responses, List<String> notes) {
        if (responses.size() < 2) {
            notes.add("Insufficient successful responses for race condition detection");
            return false;
        }

        String firstResponse = responses.get(0).getBody();
        boolean inconsistent = false;

        for (int i = 1; i < responses.size(); i++) {
            if (!responses.get(i).getBody().equals(firstResponse)) {
                inconsistent = true;
                notes.add(String.format(
                    "Response %d differs from first response - possible race condition", i));
            }
        }

        if (inconsistent) {
            notes.add("Race condition likely - inconsistent responses to identical concurrent requests");
        } else {
            notes.add("No race condition detected - all responses were consistent");
        }

        return inconsistent;
    }

    private String buildConcurrentResponseSummary(List<ResponseEntity<String>> responses) {
        return String.format("Concurrent test completed. %d/%d successful responses. Status codes: %s",
            responses.size(),
            CONCURRENCY_LEVEL,
            responses.stream()
                .map(r -> String.valueOf(r.getStatusCode().value()))
                .collect(Collectors.joining(", ")));
    }

    // ========== Payload Mutation Engine ==========

    private String preparePayload(ScanRequestDTO request, List<String> bypassTechniques, List<String> notes) {
        String payload = request.getJsonPayload();

        // Apply bypass modifications first
        if (request.isUseBypassTechniques()) {
            payload = applyBypassPayloads(payload);
            bypassTechniques.add("Applied WAF bypass payload modifications");
        }

        // Apply memory-specific mutations if this is a memory-related test
        if (isMemoryRelatedTest(request.getAttackType())) {
            payload = applyMemoryMutationTechniques(payload, notes);
            bypassTechniques.add("Added memory-testing payload mutations");
        }

        return payload;
    }

    private String applyMemoryMutationTechniques(String originalPayload, List<String> notes) {
        StringBuilder mutatedPayload = new StringBuilder(originalPayload);
        int mutationsApplied = 0;

        for (int i = 0; i < MAX_MUTATION_ATTEMPTS; i++) {
            String mutation = generateMemoryMutation();
            if (!mutatedPayload.toString().contains(mutation)) {
                mutatedPayload.append("\n// Memory test mutation: ").append(mutation);
                notes.add("Applied memory test mutation: " + mutation);
                mutationsApplied++;
            }
        }

        if (mutationsApplied == 0) {
            notes.add("No additional memory mutations applied (already present in payload)");
        }

        return mutatedPayload.toString();
    }

    private String generateMemoryMutation() {
        List<String> mutations = Arrays.asList(
            // Large data payloads
            "{\"huge_string\":\"" + generateRandomString(1024 * 1024) + "\"}", // 1MB string
            "{\"large_array\":[" + generateNumberSequence(10000) + "]}", // 10,000 element array
            "{\"deep_nested\":" + generateDeepNestedObject(10) + "}", // 10-level nested object
            
            // Edge cases
            "{\"max_int\":2147483647}",
            "{\"min_int\":-2147483648}",
            "{\"big_number\":1.7976931348623157E308}", // Double.MAX_VALUE
            "{\"special_chars\":\"\\u0000\\uFFFF\\uD83D\\uDE00\"}", // Null, non-BMP, emoji
            
            // Potentially problematic patterns
            "{\"self_ref\":{\"$ref\":\"$\"}}", // Circular reference
            "{\"prototype\":{\"__proto__\":{\"polluted\":true}}}" // Prototype pollution attempt
        );

        return mutations.get(random.nextInt(mutations.size()));
    }

    // ========== Response Pattern Analysis ==========

    private boolean analyzeResponse(String attackType, String responseBody, List<String> notes) {
        boolean vulnerable = false;
        
        // Check for memory-related error patterns
        vulnerable |= detectMemoryErrorPatterns(responseBody, notes);
        
        // Check for attack-specific indicators
        vulnerable |= checkAttackSpecificIndicators(attackType, responseBody, notes);
        
        return vulnerable;
    }

    private boolean detectMemoryErrorPatterns(String responseBody, List<String> notes) {
        boolean found = false;
        for (Pattern pattern : memoryErrorPatterns) {
            if (pattern.matcher(responseBody).find()) {
                notes.add("Detected memory error pattern: " + pattern.pattern());
                found = true;
            }
        }
        return found;
    }

    private boolean checkAttackSpecificIndicators(String attackType, String responseBody, List<String> notes) {
        switch (attackType) {
            case "Memory Shadowing":
                return checkForPatterns(responseBody, notes, 
                    Arrays.asList("\"balance\": 9999", "balance changed"), 
                    "Memory shadowing indicators found");
                    
            case "Memory Reuse After Free":
                return checkForPatterns(responseBody, notes,
                    Arrays.asList("segmentation fault", "memory error", "rce"),
                    "Use-after-free indicators found");
                    
            case "Memory-Based Session Pivoting":
                return checkForPatterns(responseBody, notes,
                    Arrays.asList("attacker_session", "admin privileges"),
                    "Session hijacking indicators found");
                    
            default:
                return checkForPatterns(responseBody, notes,
                    Arrays.asList("error", "exception", "vulnerable"),
                    "Generic vulnerability indicators found");
        }
    }

    // ========== Helper Methods ==========

    private boolean checkForPatterns(String text, List<String> notes, List<String> patterns, String successNote) {
        boolean found = false;
        for (String pattern : patterns) {
            if (text.toLowerCase().contains(pattern.toLowerCase())) {
                notes.add("Found pattern: " + pattern);
                found = true;
            }
        }
        if (found) {
            notes.add(successNote);
        }
        return found;
    }

    private boolean isMemoryRelatedTest(String attackType) {
        return attackType != null && attackType.toLowerCase().contains("memory");
    }

    private HttpHeaders prepareHeaders(ScanRequestDTO request, List<String> bypassTechniques) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        if (request.getHeaders() != null) {
            request.getHeaders().forEach(headers::set);
        }
        
        if (request.isUseBypassTechniques()) {
            bypassHeaders.forEach(headers::set);
            bypassTechniques.add("Added WAF bypass headers");
        }
        
        return headers;
    }

    private ResponseEntity<String> executeRequest(ScanRequestDTO request, HttpHeaders headers, String payload) {
        HttpEntity<String> entity = new HttpEntity<>(payload, headers);
        HttpMethod httpMethod;
        try {
            httpMethod = HttpMethod.valueOf(request.getHttpMethod().toUpperCase());
        } catch (IllegalArgumentException e) {
            httpMethod = HttpMethod.POST;
        }
        
        return restTemplate.exchange(
            request.getUrl(),
            httpMethod,
            entity,
            String.class
        );
    }

    private void buildResponse(ScanResponseDTO response, ScanRequestDTO request, 
            boolean isVulnerable, List<String> bypassTechniques, String responseData, 
            String payloadUsed, List<String> analysisNotes) {
        response.setVulnerable(isVulnerable);
        response.setVulnerabilityType(request.getAttackType());
        response.setDescription(getVulnerabilityDescription(request.getAttackType()));
        response.setPayloadUsed(payloadUsed);
        response.setBypassTechniquesUsed(bypassTechniques);
        response.setResponseData(responseData);
        
        if (!analysisNotes.isEmpty()) {
            response.setDescription(response.getDescription() + 
                "\n\nAnalysis Notes:\n• " + String.join("\n• ", analysisNotes));
        }
    }

    private void handleError(ScanResponseDTO response, Exception e) {
        response.setVulnerable(false);
        response.setDescription("Error during scanning: " + e.getMessage());
        response.setResponseData(stackTraceToString(e));
    }

    // ========== Initialization Helpers ==========

    private List<Pattern> compileMemoryErrorPatterns() {
        return Arrays.asList(
            Pattern.compile("out of memory", Pattern.CASE_INSENSITIVE),
            Pattern.compile("heap space", Pattern.CASE_INSENSITIVE),
            Pattern.compile("memory leak", Pattern.CASE_INSENSITIVE),
            Pattern.compile("segmentation fault", Pattern.CASE_INSENSITIVE),
            Pattern.compile("access violation", Pattern.CASE_INSENSITIVE),
            Pattern.compile("null pointer", Pattern.CASE_INSENSITIVE),
            Pattern.compile("buffer overflow", Pattern.CASE_INSENSITIVE),
            Pattern.compile("stack overflow", Pattern.CASE_INSENSITIVE),
            Pattern.compile("memory corruption", Pattern.CASE_INSENSITIVE),
            Pattern.compile("double free", Pattern.CASE_INSENSITIVE)
        );
    }

    private Map<String, String> initializeBypassHeaders() {
        Map<String, String> headers = new HashMap<>();
        headers.put("X-Forwarded-For", "127.0.0.1");
        headers.put("X-Originating-IP", "127.0.0.1");
        headers.put("X-Remote-IP", "127.0.0.1");
        headers.put("X-Remote-Addr", "127.0.0.1");
        headers.put("X-Client-IP", "127.0.0.1");
        headers.put("X-Host", "127.0.0.1");
        headers.put("X-Forwared-Host", "127.0.0.1");
        headers.put("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36");
        headers.put("Accept", "*/*");
        headers.put("Accept-Language", "en-US,en;q=0.5");
        headers.put("Accept-Encoding", "gzip, deflate");
        headers.put("Connection", "keep-alive");
        headers.put("Cache-Control", "no-cache");
        return headers;
    }

    private Map<String, String> initializeBypassPayloads() {
        Map<String, String> payloads = new HashMap<>();
        payloads.put("WAF_BYPASS_1", "{\"user\": {\"name\": \"admin' OR '1'='1'--\"}}");
        payloads.put("WAF_BYPASS_2", "{\"user\": {\"name\": \"admin' || '1'='1'--\"}}");
        payloads.put("403_BYPASS", "{\"user\": {\"name\": \"admin\"}, \"headers\": {\"X-Original-URL\": \"/admin\"}}");
        payloads.put("429_BYPASS", "{\"user\": {\"name\": \"admin\"}, \"X-Forwarded-For\": \"1.1.1.1\"}");
        return payloads;
    }

    // ========== Utility Methods ==========

    private String applyBypassPayloads(String originalPayload) {
        String modifiedPayload = originalPayload;
        
        // Unicode escaping
        modifiedPayload = modifiedPayload.replace("\"user\"", "\"us\\u0065r\"");
        modifiedPayload = modifiedPayload.replace("\"admin\"", "\"ad\\u006d\\u0069n\"");
        
        // Comment techniques
        if (modifiedPayload.contains("{")) {
            modifiedPayload = modifiedPayload.replace("{", "{/*bypass*/");
        }
        
        return modifiedPayload;
    }

    private String generateRandomString(int length) {
        return IntStream.range(0, length)
            .mapToObj(i -> String.valueOf((char) (random.nextInt(26) + 'a')))
            .collect(Collectors.joining());
    }

    private String generateNumberSequence(int count) {
        return IntStream.range(0, count)
            .mapToObj(i -> String.valueOf(random.nextInt(100)))
            .collect(Collectors.joining(","));
    }

    private String generateDeepNestedObject(int depth) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < depth; i++) {
            sb.append("{\"level").append(i).append("\":");
        }
        sb.append("\"value\"");
        sb.append("}".repeat(depth));
        return sb.toString();
    }

    private String stackTraceToString(Exception e) {
        return Arrays.stream(e.getStackTrace())
            .map(StackTraceElement::toString)
            .collect(Collectors.joining("\n"));
    }

    private String getVulnerabilityDescription(String attackType) {
        Map<String, String> descriptions = new HashMap<>();
        descriptions.put("Memory Shadowing", "Variable overwriting via JSON in shared memory leading to unauthorized data manipulation");
        descriptions.put("Memory Reuse After Free", "UAF in JSON parsing that could lead to RCE if pointers are involved");
        descriptions.put("TOCTOU via Memory Race", "Race condition between check and use operations allowing double-spending");
        descriptions.put("Memory-Based Session Pivoting", "Session hijacking via memory-resident session tokens");
        descriptions.put("Direct Memory Analysis", "Monitoring heap memory usage before/after requests to detect leaks");
        descriptions.put("Concurrent Request Testing", "Testing for race conditions via simultaneous requests");
        descriptions.put("Payload Mutation", "Testing with specially crafted payloads to trigger memory issues");
        return descriptions.getOrDefault(attackType, "Unknown vulnerability type");
    }
}